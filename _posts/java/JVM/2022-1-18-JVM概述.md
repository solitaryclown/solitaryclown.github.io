---
layout: post
date: 2022-01-18 12:11:07 +0800
author: solitaryclown
title: JVM
categories: Java
tags: jvm
# permalink: /:categories/:title.html
excerpt: "Java虚拟机"
---
* content
{:toc}



参考手册：<https://docs.oracle.com/javase/specs/jvms/se8/html/>
## 1. 概念
JVM，Java Virtual Machine，Java虚拟机，是Java语言二进制字节码的运行环境。
JVM只是一套规范，很多公司和组织都遵循这个规范实现了不同的JVM，目前，使用最广泛的JVM是HotSpot JVM。
### 1.1. JVM、JRE、JDK的关系
+ JRE=JVM+基础类库
+ JDK=JRE+编译工具

### 1.2. JVM的作用和规范

JVM 执行以下操作:

1. Loads code 
2. Verifies code 
3. Executes code 
4. Provides runtime environment 


JVM 提供了以下内容的定义:
- Memory area 
- Class file format 
- Register set 
- Garbage-collected heap 
- Fatal error reporting etc. 

## 2. JVM结构
JVM的内部结构包括类加载器、内存区域、执行引擎等。
示意图如下：
![JVM结构](https://static.javatpoint.com/images/jvm-architecture.png)


### 2.1. JVM内存区域（Memory Area）
JVM内存结构示意图如下：
![JVM内存区域](https://static.javatpoint.com/core/images/memory-management-in-java.png)


#### 2.1.1. 程序计数器
Program Counter(PC，程序计数器)，程序计数器包含当前线程正在执行的JVM指令的地址。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

如果当前执行的是native方法，则程序计数器中的值是未定义的。

特点：  
- PC是线程私有的，每个线程都有自己的PC，每次创建新的线程都会创建一个新的程序计数器，线程结束程序计数器被销毁。
- 程序计数器是JVM内存区域中唯一没有OOM（Out Of Memory）问题的内存区域，因为存储在程序计数器中的数据所占用的空间大小不会随着程序的执行而改变。

#### 2.1.2. JVM Stacks
Java虚拟机栈是JVM为每个线程分配的内存空间。
1. 每个栈由若干个栈帧（frames）组成，每一个栈帧对应一个方法调用所占用的内存。
2. 每个线程都有一个私有的栈，和线程同时创建。
3. 当方法被调用会创建一个栈帧，当方法调用结束销毁栈帧。

##### 2.1.2.1. 栈内存溢出
栈内存溢出是指栈的内存超过了JVM分配的栈空间内存。

栈内存溢出发生的原因：
+ 栈帧过多：常见的发生原因是过深的递归调用。
+ 栈帧过大
  
##### 2.1.2.2. 栈大小设置
使用`java -Xss大小`来设置栈的大小，其中，大小的单位可以是B、KB、MB、GB，
形式分别为：-Xss1、-Xss1K、-Xss1M、-Xss1G。  

##### 2.1.2.3. 线程问题诊断
1. CPU占用过高，例如死循环等情况。
2. CPU占用正常但程序卡住无法正常执行，例如发生死锁等情况。

当代码运行发生问题时，debug定位问题不是很方便，尤其是在多线程情况下，这时可以通过操作系统和Java本身提供的程序定位问题所在。  
在Linux系统上：
- `top`：查看进程以及系统资源的占用情况，动态变化。
- `ps -H -eo pid,tid,%cpu`：查看所有进程和进程下的线程的pid、tid和cpu占用，结果是一个快照，是静态的。
- 对于CPU占用率过高的情况，当我们利用linux命令定位到进程id（pid）和线程id（tid），然后利用`jstack pid`可以定位到问题线程和代码行。
- 当发生死锁，`jstack pid`可以直接发现死锁。

**tips**：
`ps`命令显示的进程号（tid）是十进制，jstack中有两个进程号：  
+ tid：JVM中的进程号
+ nid：系统中的进程号，以十六进制显示。

即ps命令的进程号和jstack命令输出结果中的nid是相同的，但前者是十进制，后者是十六进制。linux有现成的命令可以将十进制以十六进制显示：`printf "%x" 十进制整数`。


#### 2.1.3. 本地方法栈（Native Method Stacks）
给native方法执行提供内存空间


#### 2.1.4. 堆（Heap）
堆是所有JVM线程共享的内存区域，所有的class实例和数组都在堆中分配内存。

特点：  
1. JVM启动时创建堆
2. 所有JVM线程共享
3. 内存由垃圾收集器回收

##### 2.1.4.1. 设置堆内存大小
+ `-Xmx<size>`：设置最大的Java堆大小
+ `-Xms<size>`：设置初始的Java堆大小
size的单位默认是byte，可以显示设置为k、m、g

**tips**：命令`java -X`可以显示所有参数的用法。

##### 2.1.4.2. jmap 
map 打印给定进程、核心文件或远程调试服务器的共享对象内存映射或堆内存细节。如果给定的进程在64位 VM 上运行，您可能需要指定 -j-d64选项，例如:
`jmap -J-d64 -heap pid`

查看pid可以用操作系统命令，也可以使用jps快捷查看。

#### 2.1.5. 方法区（Method Area）
方法区在JVM线程间共享，用来存储每个类的结构，比如运行时常量池、字段和方法数据以及普通方法和构造方法的代码，以及用于class的special methods、实例初始化和接口初始化的信息。

+ 方法区在JVM启动时创建
+ 方法区在逻辑上是堆的一部分，但简单的实现也许不会对其进行垃圾回收。
+ Method Area是一种规范，不同的JVM对其有不同的实现。对于Hotspot，Java8以前，对方法区的实现的区域称作**永久代**，是JVM堆的一部分。Java8移除了**永久代**，用了**元空间**（Metaspace）作为方法区的新的实现，并且Metaspace是在本地内存中分配而不是在JVM堆中分配。

方法区在规范上存在内存溢出的问题，但Java8的方法区实现即元空间在本地内存中分配，一般不会出现内存溢出问题。

##### 2.1.5.1. 常量池
类文件将其所有的符号引用保存在一个地方，即常量池。每个类文件都有一个常量池，由 Java 虚拟机加载的每个类或接口都有一个称为**运行时常量池**的常量池的内部版本。运行时常量池是一种特定于实现的数据结构，映射到类文件中的常量池。

###### 2.1.5.1.1. StringTable
StringTable是字符串常量池，用来存放字符串常量，逻辑上属于常量池的一部分，数据结构为哈希表。

Java7中将StringTable从方法区移到了堆中。Java8保留了这一更改，并且Java8将方法区（除StringTable外）的实现用元空间替代了永久代，并移到本地内存中。

string table相关参数：
+ 打印spring table统计数据：`-XX:+PrintStringTableStatistics`  
  示例结果：
  ```
  SymbolTable statistics:
    Number of buckets       :     20011 =    160088 bytes, avg   8.000
    Number of entries       :     16171 =    388104 bytes, avg  24.000
    Number of literals      :     16171 =    665648 bytes, avg  41.163
    Total footprint         :           =   1213840 bytes
    Average bucket size     :     0.808
    Variance of bucket size :     0.806
    Std. dev. of bucket size:     0.898
    Maximum bucket size     :         6
    StringTable statistics:
    Number of buckets       :      1009 =      8072 bytes, avg   8.000
    Number of entries       :    482773 =  11586552 bytes, avg  24.000
    Number of literals      :    482773 =  29826096 bytes, avg  61.781
    Total footprint         :           =  41420720 bytes
    Average bucket size     :   478.467
    Variance of bucket size :   432.071
    Std. dev. of bucket size:    20.786
    Maximum bucket size     :       547
  ```
+ 调整string table的桶数量（buckets）：`-XX:StringTableSize=1009`  
  string table的桶数量越大，哈希冲突越少，每个桶存储的元素越少，存储速度和查找速度越快。


#### 2.1.6. 垃圾回收（Garbage Collection）
##### 2.1.6.1. 如何判断对象可以回收
    - 引用计数法
    - 可达性分析法
Hotspot采用的是**可达性分析法**来判断对象是否可被回收。
GC Roots是JVM中不会被回收的对象。
###### 2.1.6.1.1. 五种引用
java.lang.ref包提供引用对象类，利用这些类可以和GC实现有限的交互，避免了手动`System.gc()`的Full GC。
1. 强引用
在Java中，使用`new`创建的对象直接复制给某个变量叫做**强引用**，这种引用指向的对象，JVM即使抛出OOM也不会GC回收。

2. 软引用（SoftReference）
3. 弱引用（WeakReference）
4. 虚幻引用（PhantomReference）
5. 终结器引用
#### 2.1.7. 垃圾回收算法


#### 2.1.8. 分代垃圾回收
#### 2.1.9. 垃圾回收器