---
layout: post
date: 2022-08-03 18:44:03 +0800
author: solitaryclown
title: Halcon基础
categories: 机器视觉
tags: 
excerpt: "Halcon基础"
---
* content
{:toc}


# 1. Halcon基础

## 1.1. 图像采集和XLD
1. 通道分解和组合
   ```halcon
   * Image Acquisition 01: Code generated by Image Acquisition 01
    read_image (img, 'C:/Users/SKQ/Desktop/fruit.jpg')

    count_channels(img,channelNum)
    for i:=1 to channelNum by 1
        access_channel(img,currentCnlImg,i)
        stop()
    endfor
    *分解通道
    decompose3 (img,R,G,B)
    *合并通道
    compose3(R,G,B,RAddG)
   ```
2. 图像获取、阈值分割
   ```
    * Image Acquisition 01: Code generated by Image Acquisition 01
    *关闭窗口
    dev_close_window()
    read_image (img, 'egypt1.png')
    *获取图像尺寸
    get_image_size(img,width,height)
    *显示图片
    dev_open_window(0,0,width,height,'black',Whandle)
    dev_display(img)
    *阈值分割
    threshold (img, region, 23, 131)
    *显示结果
    dev_display(region)
   ```
3. 数据结构
   ```
   n:=20
    arr[0]:='asad'
    arr[10]:=30
    arr[9]:=n*arr[10]

    *初始化一个数组，指定输出
    tuple_gen_const(100,13,nums)

    *初始化一个输出
    nums:=gen_tuple_const(10,1234)
   ```

4. 流程分支
    ```
    a:=10
    if (a<=0)
        * true为1
        y:=true
    elseif(a!=10)
        *false为0
        y:=false
    else 
        y:=20
    endif


    score:=90
    if(score>90 and score<=100)
        result:='优秀'
    endif



    * switch结构
    result:=''
    idx:=1
    switch (idx)
    case 1:
        result:='OK'
        break
    case 2:
        result:='NG'
        break
    case 3:
        result:='NONE'
        break
    default:
        result:='ERROR'
    endswitch
    ```
5. 循环结构
   ```
   *建立一个空数组
    arr:=[]
    * for
    for i:=1 to 10 by 1
        arr[i-1]:=i
    endfor
    stop()
    *arr=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    *数组赋值的特殊语法
    arr:=[]
    for i:=1 to 10 by 1
        arr:=[arr,i]
    endfor
    stop()
    *arr=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    *break
    arr:=[]
    for i:=1 to 10 by 1
        if(i==3)
            continue
        endif
        if(i==7)
            break
        endif
        arr:=[arr,i]
    endfor
    * arr=[1,2,4,5,6]


    * While循环
    flag:=false
    arr1:=[]
    num:=5 
    i:=0
    while(flag==false)
        if(i==num)
            flag:=true
        else
            arr1:=[arr1,i]
            i:=i+1
        endif
    endwhile
    * arr1=[0,1,2,3,4]


    * repeat until循环
    flag:=false
    arr2:=[]
    j:=0
    cnt:=10
    repeat
        arr2:=[arr2,j]
        if(j==cnt)
            flag:=true
        else
            j:=j+1
        endif
    until (flag=true)
    ```
6. ROI绘制
    ```
    dev_close_window()
    * Image Acquisition 01: Code generated by Image Acquisition 01
    read_image (img, 'C:/Users/Public/Documents/MVTec/HALCON-18.11-Progress/examples/images/claudia.png')

    dev_open_window_fit_image(img,0,0,-1, -1, WindowHandle)

    dev_display(img)

    *交互式画图，程序执行时在窗口绘画ROI，点击右键完成绘制，程序继续执行
    draw_rectangle1(WindowHandle,r1,col1,r2,col2)
    *生成ROI
    gen_rectangle1 (ROI_0, r1,col1,r2,col2)
    *减少处理区域
    reduce_domain(img,ROI_0,img_reduced)
    dev_display(img_reduced)
    ```
7. 




### 1.1.1. XLD
extended line descriptor，扩展的直线描述符，是一种描述亚像素的数据结构。

1. 亚像素级边缘提取
   ```halcon
   * Image Acquisition 01: Code generated by Image Acquisition 01
    *关闭窗口
    dev_close_window()
    read_image (img, 'fabrik')
    *打开适应图片大小的窗口
    dev_open_window_fit_image(img,0,0,-1,-1,Whandle)

    edges_sub_pix(img,edges,'canny',2,12,22)
    *显示
    dev_display(edges)
   ```
2. 

## 1.2. 匹配
1. *correlation-based matching*，基于相关性的匹配，基于灰度值
2. *shape-based matching*，基于形状的匹配，基于提取的边缘生成特征模型来匹配
3. *component-based matching*，可以看做高级的形状匹配，高级之处在于特征可以由可以移动的多个部分（旋转和平移）组成
4. *local deformable matching*，局部变形匹配，跟形状匹配类似，但可以对形变进行处理并返回矫正的特征模型。
5. *perspective deformable matching*，透视变形匹配，跟形状匹配类似，
可以对强透视形变进行处理。
6. *descriptor-based matching*，跟透视形变匹配类似，主要区别在于基于点而不是边缘来创建和查找匹配模型。
7. *3D matching*，由许多不同的方法组成
8. *point-based matching*，基于点的匹配，目的是合并两幅重叠的图像，匹配的结果是从一幅图像到另一幅图像的映射。


