---
layout: post
date: 2022-06-18 15:44:03 +0800
author: solitaryclown
title: 
categories: 
tags: 
# permalink: /:categories/:title.html
excerpt: ""
---
* content
{:toc}


# 1. c#基础
## 1.1. c#方法参数
c#方法的参数一共有四种:
1. 值参数:参数传递的是副本
2. 引用参数:参数传递的是变量的引用。
   + 方法定义:修饰符 返回值 方法名(`ref` 参数类型 形参名)
   + 方法调用:方法名(`ref` 实参名)
3. 输出参数:和引用参数类似，但方法内部任何的执行路径必须对输出参数赋值。
   + 方法定义:修饰符 返回值 方法名(`out` 参数类型 形参名)
   + 方法调用:方法名(`out` 实参名)
4. 可变参数（参数数组）:可以传递任意个数参数，会被封装到参数数组中
   + 方法定义:修饰符 返回值 方法名(`params` 参数类型[] 形参名)
   + 方法调用:方法名(`arg1[,arg2,...]`);

```csharp
using System;

namespace var_method_param
{
    class Point
    {
        int x;
        int y;
        public void Print()
        {
            Console.WriteLine("({0},{1})", x, y);
        }
    }
    class Program
    {
        static void Main(string[] args)
        {

            var point = new Point();
            //类的字段默认是private访问级别
            //point.x = 3;
            point.Print();


            Console.WriteLine(Sum(5, 15));

            int a = 11, b = 22;
            Console.WriteLine("交换两个变量的值：");
            Console.WriteLine("交换前:a={0},b={1}", a, b);
            Swap(ref a, ref b);
            Console.WriteLine("交换前:a={0},b={1}", a, b);


            Console.WriteLine("-----------out参数---------");
            int outP;
            OutParam(3, out outP);
            Console.WriteLine("outP:"+outP);


            Console.WriteLine("-----------可变参数（参数数组）---------");
            Print(1, 2, 3, 4, 5);
            Print(3, 4, 11);
        }

        /*
         * c#参数类型：
         *      1.值类型
         *      2.引用类型
         *      3.传出类型
         *      4.可变参数
         * 
         * 
         */

        /// <summary>
        /// 值参数
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns>两数之和</returns>
        static int Sum(int a, int b)
        {
            return a + b;
        }

        /// <summary>
        /// 引用参数
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        static void Swap(ref int a, ref int b)
        {
            int temp = a;
            a = b;
            b = temp;
        }

        /// <summary>
        /// out参数
        /// </summary>
        /// <param name="iParam"></param>
        /// <param name="outParam"></param>
        static void OutParam(int iParam, out int outParam)
        {
            outParam = iParam * 2;
        }
        /// <summary>
        /// 可变参数
        /// </summary>
        /// <param name="args"></param>
        static void Print(params int[] args)
        {
            for (int i = 0; i < args.Length; i++)
            {
                Console.Write(args[i]);
                if (i < args.Length-1)
                {
                    Console.Write(",");
                }
                else
                {
                    Console.WriteLine();
                }
            }
        }
    }
}
```

另外，c#的方法参数可以指定默认值，在调用方法时对于指定了默认值的参数可以不用传递，如下所示:
```csharp
static int GetOffset(int pageSize = 10, int page = 1)
{
    return (page - 1) * pageSize;
}
```

## 1.2. c#类

### 1.2.1. 修饰符
+ const：常量修饰符
+ readonly: 类似于常量修饰符，一旦值被设定就不能改变，但和const也有区别:
    const字段或变量只能在声明语句中初始化，值必须在编译期确定，没有内存空间;readonly字段有内存空间，可以在声明语句或者constructor中初始化。

### 1.2.2. 类成员
c#的类有9种成员:
#### 1.2.2.1. 字段
   + 实例字段:类中的变量，每个实例有自己的字段
   + 类字段（静态字段）:类的所有实例共享的变量
#### 1.2.2.2. 常量
   `const`修饰的变量，对所有实例可见，和static关键字冲突。只能通过类名.常量访问，且常量的值必须在编译期确定，常量在编译器被替换，没有自己的存储空间。
#### 1.2.2.3. 方法
#### 1.2.2.4. 属性
   属性代表类的实例或类中的数据项的成员。
   属性的特征:
   + 是命名的类成员
   + 有类型
   + 可以被赋值和读取

    属性和字段的区别：
    + 属性是函数成员
    + 属性不为数据存储分配内存
    + 属性执行代码

    属性的本质是一组两个匹配的、成为**访问器**的方法：
    + set访问器为属性赋值
    + get访问器从属性获取值
    
1. 属性声明和访问器
set访问器性质:
+ 拥有一个单独的、隐式的值，名称为value，和属性的类型相同
+ 拥有一个返回类型void

get访问器性质:
+ 参数为void
+ 拥有一个返回值，和属性类型相同

声明一个属性:
```csharp
[修饰符] 类型 属性名{
    set{
        一些代码
    }
    get{
        一些代码
        return 返回值;
    }
}
```

由于属性没有存储空间，常常和字段关联使用，且通常的命名规范是：字段使用Camel命名风格，即首字母小写，其他所有单词首字母大写;属性使用Pascal命名风格，所有单词首字母大写。

2. 只读和只写属性
   通过只实现set或者get访问器来实现只写或只读
3. 自动生成属性
   c#允许只声明属性不声明其关联的后备字段，编译器会自动创建隐藏的字段，并且自动挂接到set和get访问器上。自动实现属性的要点:
   + 不声明后备字段，编译器根据属性的类型自动创建
   + 访问器set和get不能提供方法体，只写简单的分号

4. 静态属性
   跟静态字段一样，必须使用类名访问。

#### 1.2.2.5. 构造函数（constructor）
    类实例化时执行的函数
#### 1.2.2.6. 析构函数（destructor）
    类被销毁之前执行的函数，一般用来清理或释放**非托管资源**，非托管资源是指通过Win32 API获取的文件句柄或非托管内存块，使用.NET是无法获得它们的，所以如果只是使用了.net类，就不需要编写destructor函数
#### 1.2.2.7. 运算符

#### 1.2.2.8. 索引
    
#### 1.2.2.9. 事件



### 1.2.3. partial类和partial方法
c#允许将一个class分成多个partial class声明，同时允许class的方法在不同的partial class中声明和实现，这种声明和实现分开的方法用partial修饰。

partial方法的性质如下：
1. 返回值必须是**void**
2. 方法签名不能有访问修饰符，这使得partial方法默认是隐式私有的。
3. partial方法**必须有声明**，实现可以有可以没有，如果没有实现，编译器把方法的声明和任何对方法的调用部分都移除。

示例：
```csharp
partial class PClass
{
    //方法声明
     partial void M1();
}


partial class PClass
{
    //方法实现
    partial void M1()
    {
        Console.WriteLine("partial method...");
    }
    public int Add(params int[] nums)
    {
        
        M1();
        int sum = 0;
        for(int i=0; i < nums.Length;i++)
        {
            sum += nums[i];
        }
        return sum;
    }
}
```

### 1.2.4. 继承
c#所有的类都继承自基类object。
C#实现继承的语法:
```csharp
class DerivedCalss:BaseClass{
    ...
}
```

#### 1.2.4.1. 字段覆盖和方法覆盖
在派生类中对字段和方法使用`new`关键字修饰实现覆盖基类的成员和方法
```csharp
using System;

namespace test
{
    class Program
    {
        static void Main(string[] args)
        {
            Dog d = new Dog();
            Animal a = d;
            a.Eat();
            d.Eat();
        }

        class Animal
        {
            public void Eat()
            {
                Console.WriteLine("动物吃东西.");
            }
        }
        class Dog : Animal
        {
            new public void Eat()
            {
                Console.WriteLine("狗吃骨头.");
            }
        }
    }
}

```

输出：
```
动物吃东西.
狗吃骨头.
```

#### 1.2.4.2. virtual方法和override方法
对于使用new修饰的方法，如果使用基类的引用，那么调用的还是基类的方法，如果想要使用基类的引用调用派生类的方法，可以对基类方法使用`virtual`修饰，派生类的方法用`override`修饰。
性质如下:
1. virtual方法和override方法必须具有相同的访问级别
2. 不能对static方法使用override
3. 对于方法、属性、索引器和成员类型事件，都可以使用virtual和override

示例：
```csharp
using System;

namespace test
{
    class Program
    {
        static void Main(string[] args)
        {
            Dog d = new Dog();
            Animal a = d;
            a.Eat();
            d.Eat();
        }

        class Animal
        {
            virtual public void Eat()
            {
                Console.WriteLine("动物吃东西.");
            }
        }
        class Dog : Animal
        {
            public override void Eat()
            {
                Console.WriteLine("狗吃骨头.");
            }
        }
    }
}
```
输出:
```
狗吃骨头.
狗吃骨头.
```

## 1.3. C#运算符

### 1.3.1. 运算符重载
c#允许自定义运算符如何操作自定义的类型。

```csharp
using System;

namespace operators
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
            LimitedInt a = new LimitedInt();
            LimitedInt b = new LimitedInt();

            a.TheValue = 11;
            b.TheValue = 22;

            LimitedInt c = -a;
            LimitedInt d = a + b;
            Console.WriteLine("c:{0}", c.TheValue);
            Console.WriteLine("d:{0}", d.TheValue);
            Console.WriteLine("(a+b)的值:{0}",(a + b).TheValue);

            a.TheValue = 300;
            Console.WriteLine(a.TheValue);


        }
    }
    class LimitedInt
    {
        const int MaxValue = 100;
        const int MinValue = 0;

        int _theValue = 0;
        
        public int TheValue 
        {
            get
            {
                return _theValue;
            }
            
            set
            {
                if (value < MinValue)
                {
                    _theValue = 0;
                }
                else
                {
                    _theValue=value > MaxValue ? MaxValue : value;
                }
            }
        }
        public static LimitedInt operator -(LimitedInt x)
        {
            LimitedInt li=new  LimitedInt();
            li.TheValue = 0;
            return li;
        }
        public static LimitedInt operator +(LimitedInt a,LimitedInt b)
        {
            LimitedInt li = new LimitedInt();
            li.TheValue = a.TheValue + b.TheValue;
            return li;
        }
    }
}

```

结果：
```
Hello World!
c:0
d:33
(a+b)的值:33
100
```


## 1.4. 语句
1. 表达式语句
2. 控制流语句
   + 条件：if-else、switch-case
   + 循环：for、while、do-while、
   + 跳转：break、continue、goto
3. using语句（语法糖）
using语句用来隐式关闭资源，**资源**是指一个实现了`System.IDisposable`接口的类或者结构，using语句功能跟Java中的try-with-resources语句相似。

   示例：
   ```csharp
   //using语句
    string path="Lincoln.txt";
    using (TextWriter tw = File.CreateText(path))
    {
        tw.WriteLine("Four score and seven years ago,...");
        tw.WriteLine("HelloWorld");
        tw.WriteLine("The END");
    }
    using(TextReader tr = File.OpenText(path))
    {
        Console.WriteLine("从文件{0}中读取到下面的内容:", path);
        string line;
        while ((line = tr.ReadLine()) != null)
        {
            Console.WriteLine(line);
        }
    }
   ```

4. checked和unchecked语句
5. foreach语句
6. try、throw、finally
7. yield
   
## 1.5. 结构体(struct)
struct是自定义的数据类型，和class相似，可以有数据成员和函数成员，但和class有如下的区别:
1. struct是值类型，内存在栈上分配；class是引用类型，内存在堆上分配
2. struct是隐式密封(sealed)的，不能被派生

示例：
```csharp
using System;

namespace Struct
{
    class Program
    {
        //结构体
        struct Point
        {
            public int X;
            public int Y;
        }
        static void Main(string[] args)
        {
            //Console.WriteLine("Hello World!");
            Point pa, pb, pc;
            pa.X = 10; pa.Y = 10;
            pb.X = 20; pb.Y = 20;
            pc.X = pa.X + pb.X; pc.Y = pa.Y + pb.Y;
            Console.WriteLine(pa.X);

            Point tempP = pc;
            Console.WriteLine("tempP:({0},{1})", tempP.X, tempP.Y);
            tempP.X = -1;
            Console.WriteLine("tempP:({0},{1})", tempP.X, tempP.Y);
            Console.WriteLine("pc:({0},{1})", pc.X, pc.Y);
        }
    }
}

```


### 1.5.1. struct的成员
#### 1.5.1.1. 函数
1. strcut可以有构造函数（包括静态构造函数），不能有析构函数
2. c#为struct隐式创建了无参构造函数，不能删除和手动定义。
3. 在创建strcut实例时，如果要使用构造函数，必须和创建class实例一样使用`new`关键字，即使struct不是在堆中分配内存；如果不使用new创建实例，有如下限制:
    + 字段在使用前必须显式赋值
    + 任何函数成员被调用前要保证所有字段已经赋值
4. 静态构造函数用于初始化静态字段，在下面的情况之前会被调用:
    + 调用显示声明的构造函数
    + 引用结构的静态成员



#### 1.5.1.2. 字段
在struct中，实例字段声明时不能初始化，要么在构造函数中初始化，要么显式赋值。



## 1.6. 数组

`C#中的数组都是继承自System.Array`

C#的一维数组的使用和Java类似，多维数组的语法稍有不同，下面是一个C#中使用二维数组的示例:
```csharp
using System;

namespace testArray
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
            int[,] map = new int[3, 3] {
                {1,2,3 },
                {4,5,6 },
                {7,8,9 }
            };
            for (int i = 0; i < map.GetLength(0); i++)
            {
                for (int j = 0; j < map.GetLength(1); j++)
                {
                    Console.Write("{0}\t", map[i, j]);
                }
                Console.WriteLine();
            }

        }
    }
}

```

### 1.6.1. foreach遍历数组
```csharp
//foreach遍历
Console.WriteLine("foreach遍历数组:");
int total = 0;
foreach(var n in map)
{
    total += n;
    Console.WriteLine("当前元素:{0}，total:{1}",n,total);
}
```

运行结果:
```
foreach遍历数组:
当前元素:1，total:1
当前元素:2，total:3
当前元素:3，total:6
当前元素:4，total:10
当前元素:5，total:15
当前元素:6，total:21
当前元素:7，total:28
当前元素:8，total:36
当前元素:9，total:45
```


## 1.7. 委托
委托相当于函数/方法的指针，可以在运行时决定执行**哪些方法**（一个委托可以执行多个方法）。

示例:
```csharp
using System;

namespace testDelegate
{
    class Program
    {
        //声明委托
        delegate void MyDel(int value); 
        void PrintLow(int value)
        {
            Console.WriteLine("Low value:{0}", value);
        }
        void PrintHigh(int value)
        {
            Console.WriteLine("High value:{0}", value);
        }
        static void Main(string[] args)
        {
            Program p = new Program();
            Console.WriteLine("Hello World!");
            MyDel del;
            //生成0-99之间的随机数
            Random random = new Random();
            int randomValue = random.Next(99);
            del = randomValue > 50 ? new MyDel(p.PrintHigh) : new MyDel(p.PrintLow);
            del(randomValue);

            //组合委托

            Console.WriteLine("组合委托:");
            MyDel del2;
            //委托初始化的快捷语法，相当于del2=new MyDel(p.Method1)
            del2 = p.Method1;
            del2(10);
            //组合委托的语法，相当于del执行时Method1和Method2都会执行一次
            del2 += p.Method2;
            del2(20);

            //从委托移除方法
            del2 = del2 - p.Method1;
            del2(30);

        }

        void Method1(int v)
        {
            Console.WriteLine("Method1:" + v);
        }
        void Method2(int v)
        {
            Console.WriteLine("Method2:" + v);
        }
    }
}
```

运行结果:
```
Hello World!
Low value:16
组合委托:
Method1:10
Method1:20
Method2:20
Method2:30
```

委托保存的方法可以是静态方法，也可以是实例方法，只要委托和方法的**返回值类型**和**签名（包括ref、out修饰符）**一致


### 1.7.1. 委托的相关运算
1. 组合委托
   `+`运算符用来组合多个委托

   ```csharp
   MyDel del1=...,del2=...;
   MyDel del3=del1+del2;
   ```
   del3相当于del1和del2的方法列表的和，del3执行一次，del1和del2包括的所有方法都会执行一次。
2. 委托添加方法
   `+=`运算符用来给委托添加方法，前提是委托的引用已经初始化。
    ```csharp
    MyDel del=M1;
    del+=M2;
    ```
3. 委托删除方法
   `-=`运算符用来删除委托中的某个方法，前提是委托的引用已经初始化。
   ```csharp
    MyDel del=M1;
    del+=M2;del+=M3;
    del-=M1;
    //最终del=M2+M3
    //注意下面的情况:
    MyDel del=M1;
    del-=M1;
    //此时del是null，如果执行del()会抛出空指针异常
    ```
### 1.7.2. 带有返回值的委托
如果委托有返回值且委托包含了多个方法，那么委托的返回值是**最后一个方法的返回值**。

```csharp
namespace testDelegate
{
    
    //委托是类不是方法，所以可以直接定义在namespace下
    delegate int MyDel();

    class Class1
    {
        public int M1()
        {
            return 10;
        }
        public int M2()
        {
            return 20;
        }
        
    }
}

//测试
 Class1 c1=new Class1();
MyDel del1;
MyDel del2;
del1 = c1.M1;
del1 += c1.M
del2 = c1.M2;
del2 += c1.M
Console.WriteLine("del1()={0}", del1());
Console.WriteLine("del2()={0}", del2());
```

结果:
```
del1()=20
del2()=10
```


### 1.7.2. 带有引用参数的委托
当委托参数使用引用时，引用会依次传给下一个方法。

### 1.7.3. 匿名方法
**匿名方法**(anonymous method)是指初始化委托时内联的方法。
如果某些代码只会在一个地方调用那么就没有必要声明成一个单独的方法，可以使用匿名方法。

```csharp
MyDel del = delegate ()
{
    Console.WriteLine("匿名方法");
};
del();
```


下面这种情况可以省略匿名方法的圆括号：
1. 委托的参数不包含out参数
2. 匿名方法不使用参数

#### 1.7.3.1. 匿名方法的变量作用域

和委托方法不同，匿名方法可以访问方法作用域之外的变量和环境。
```csharp
int outVariable = 10;
MyDel del = delegate
{
    Console.WriteLine("访问到外部变量:" + outVariable);
};
del();
```

对于块之外的代码访问不到块之内的变量:
```csharp
//块之外的代码访问不到
{
    int outVariable2 = 20;
    MyDel del2 = delegate
    {
        Console.WriteLine("访问到外部变量:" + outVariable2);
    };
    del2();
}
//下面的代码访问不到outVariable2
//Console.WriteLine("访问到外部变量:" + outVariable2);
```


#### 1.7.3.2. Lamda表达式
Lamda表达式是匿名方法的变种，但比匿名方法简洁。
```csharp
MyDel del = (int n) =>
  {
      return n * 2;
  };
Console.WriteLine(del(10));
```
Lamda表达式可以更进一步简略:
1. 如果只有一个参数，圆括号可以省略;
2. 参数类型可以省略(隐式类型)，但如果参数有ref和out修饰符，则不能省略类型关键字
3. 如果方法体只有一条返回语句，可以省略大括号和return关键字。
```csharp
MyDel del = x => x / 2;
Console.WriteLine(del(10));//5
```





## 1.8. 事件
### 1.8.1. 相关概念
publisher:事件发布者，发布某个事件的类或结构，其他类可以在事件发生时得到通知
subscriber:事件订阅者，注册并在事件发生时得到通知的类或结构
event handler:订阅者注册到事件中的方法，发布者发布事件时执行
raise event:触发(invoke/fire)事件的行为，当事件触发时，所有注册到它的方法都会依次执行。


### 1.8.2. 使用事件的源代码组件概览
[![jFNDrF.png](https://s1.ax1x.com/2022/06/24/jFNDrF.png)](https://imgtu.com/i/jFNDrF)

c#的事件依赖于委托。
```csharp
using System;
using System.Collections.Generic;
using System.Text;

namespace testEvent
{
    //声明一个委托
    delegate void Handler();

    /// <summary>
    /// publisher
    /// </summary>
    /// 
    class Incrementer
    {
        //event关键字限制委托变量只能进行+=和-=运算
        public event Handler CountedADozen;
        public void DoCount()
        {
            for (int i = 1; i < 100; i++)
            {
                if (i % 12 == 0 && CountedADozen != null)
                {
                    Console.WriteLine("{0}%12==0", i);
                    CountedADozen();
                }
            }
        }
    }
}

```

```csharp
using System;
using System.Collections.Generic;
using System.Text;

namespace testEvent
{
   /// <summary>
   /// subscriber
   /// </summary>
    class Dozens
    {
        public int DozensCount
        { get; private set; }
        public Dozens(Incrementer incrementer)
        {
            DozensCount = 0;
            //订阅事件
            incrementer.CountedADozen += IncrementDozensCount;
        }
        void IncrementDozensCount()
        {
            DozensCount++;
        }
    }
}

```

```csharp
namespace testEvent
{
    class Program
    {
        static void Main(string[] args)
        {
            Incrementer incrementer = new Incrementer();
            Dozens dozensCounter = new Dozens(incrementer);
            incrementer.DoCount();

            Console.WriteLine("Numbers of dozens count:{0}",dozensCounter.DozensCount);
        }

    }
}
```

运行结果：
```
12%12==0
24%12==0
36%12==0
48%12==0
60%12==0
72%12==0
84%12==0
96%12==0
Numbers of dozens count:8
```

### 1.8.3. C#标准事件用法
在`System`命名空间下有一个`EventHandler`是标准的委托类型。


```csharp
using System;
using System.Collections.Generic;
using System.Text;

namespace testEvent_standard
{
    /// <summary>
    /// 自定义EventArgs
    /// </summary>
    class IncrementEventArgs:EventArgs
    {
        public int IterationCount { get; set; }
    }
}

```

```csharp
using System;
using System.Collections.Generic;
using System.Text;

namespace testEvent_standard
{
    
    class Incrementer
    {
        //System.EventHandler
        //public delegate void EventHandler(object sender,EventArgs e)
        public event EventHandler<IncrementEventArgs> CountedADozen;

        public void DoCount()
        {
            //传递事件参数
            IncrementEventArgs args = new IncrementEventArgs();
            for (int i = 1; i < 100; i++)
            {
                if (i % 12 == 0 && CountedADozen != null)
                {
                    args.IterationCount = i;
                    CountedADozen(this, args);
                }
            }
        }
    }
}

```

```csharp
using System;
using System.Collections.Generic;
using System.Text;

namespace testEvent_standard
{
    class Dozens
    {
        //声明一个DozensCount属性
        public int DozensCount { get; private set; }
        public Dozens(Incrementer incrementer)
        {
            DozensCount = 0;
            incrementer.CountedADozen += IncrementDozensCount;
        }
        
        void IncrementDozensCount(object source,IncrementEventArgs e)
        {
            Console.WriteLine("Incremented at interation: {0} in {1}", e.IterationCount, source.ToString());
            DozensCount++;
        }
    }
}

```

```csharp
namespace testEvent_standard
{
    class Program
    {
        static void Main(string[] args)
        {
            //Console.WriteLine("Hello World!");

            Incrementer incrementer = new Incrementer();
            Dozens dozens = new Dozens(incrementer);

            incrementer.DoCount();

            Console.WriteLine("{0}", dozens.DozensCount);
        }
    }
}
```

### 1.8.4. 移除事件处理程序
使用-=运算符移除事件


## 1.9. interface
### 1.9.1. 性质
interface中不能声明:
1. 数据成员
2. 静态成员

inteface声明只能包含如下类型的非静态成员函数的声明:
1. 方法
2. 属性
3. 事件
4. 索引器
且这些成员函数不能有任何的实现。


### 1.9.2. 显示的成员实现
显示的接口成员实现是指在方法实现时限定接口名，调用时通过对应的接口调用。
```csharp
class MyClass2 : I1, I2
{
    void I1.PrintOut(string s)
    {
        Console.WriteLine("interface 1:{0}",s);
    
    void I2.PrintOut(string s)
    {
        Console.WriteLine("interface 2:{0}", s)
    }
}
```

结果：
```
interface 1:hello
interface 2:hello
```




## 1.10. C#类型转换
### 1.10.1. 数值类型转换

数值类型的隐式转换关系如下图：
[![jn0U4x.png](https://s1.ax1x.com/2022/06/29/jn0U4x.png)](https://imgtu.com/i/jn0U4x)


#### 1.10.1.1. 溢出检测
##### 1.10.1.1.1. checked运算符

c#提供`checked(表达式)`和`unchenked(表达式)`实现数值转换时的溢出，如果使用checked对语句进行检测，在发生数据溢出时会抛出OverflowException

如下面的代码在运行时会抛出`System.OverflowException`
```csharp
 //checked和unchecked检测溢出
 byte sb;
 ushort sh = 2000;
 sb = checked((byte))sh
 Console.WriteLine(sb);
```

##### 1.10.1.1.2. checked语句块
checked语句的功能和checked表达式一样，但检测的是多个语句。

### 1.10.2. 引用类型转换
引用类型的对象由引用和数据组成，引用包含的信息是指向的对象的类型。

引用转换：引用转换接收源引用并返回一个指向堆中同一位置的引用，但把引用标记为其他的数据类型。


#### 1.10.2.1. 隐式引用转换
引用也有隐式转换，且隐式转换发生在以下情况:
1. 任何引用类型可以隐式转换成object类型
2. 引用可以隐式转换成：
   + 继承链中的任何一个类型
   + 实现的任何接口