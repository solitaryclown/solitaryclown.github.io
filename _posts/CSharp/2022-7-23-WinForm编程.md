---
layout: post
date: 2022-07-22 15:44:03 +0800
author: solitaryclown
title: WinForm编程
categories: C#
tags: WinForm
# 1. permalink: /:categories/:title.html
excerpt: "WinForm编程相关知识"
---
* content
{:toc}



# 1. Winform编程
## 1.1. Form
### 1.1.1. 基础概念
+ 显示
	WinForm的显示主要可以通过两种方法：
	+ `form1.Show()`
	+ `form1.ShowDialog()`
	这两个方法的区别是`Show()`方法展示的窗口和调用者之间没有关系，而`ShowDialog()`会导致显示窗口和调用者之间存在Owner-Owned的关系。


### 1.1.2. Form生命周期
Form生命周期如下图所示：
[![jXGymn.png](https://s1.ax1x.com/2022/07/23/jXGymn.png)](https://imgtu.com/i/jXGymn)

1. FormClosing事件
	FormClosing在窗口关闭（Close）之前发生，可以在处理事件方法中添加窗口关闭的确认提示：
	```csharp
	private void Form1_FormClosing(object sender, FormClosingEventArgs e)
    {
        DialogResult result = MessageBox.Show("退出系统？", "关闭提示", MessageBoxButtons.YesNo);
        e.Cancel = (result == DialogResult.No);
    }
	```
	此外，FormClosing也是保存form相关属性数据（比如size、location等）最合适的地方。
	
2. 

## 1.2. Dialog

## 1.3. Drawing

### 1.3.1. Graphics

```csharp
bool drawEllipse = false;
        private void btnDrawing_Click(object sender, EventArgs e)
        {

            drawEllipse = !drawEllipse;
            using (Graphics g = this.CreateGraphics())
            {
                if (this.drawEllipse)
                {
                    // Draw the ellipse 
                    g.FillEllipse(Brushes.AliceBlue, this.ClientRectangle);
                }
                else
                {
                    // Erase the previously drawn ellipse 
                    g.FillEllipse(SystemBrushes.Control, this.ClientRectangle);
                }
            }
        }
```

### 1.3.2. Color
`Color`是一个struct类型，表示颜色。

示例：
```csharp
private void button2_Click_1(object sender, EventArgs e)
{
    Button btn = (Button)sender;
    //btn.BackColor = ColorTranslator.FromHtml("#00FFFF");
    btn.BackColor = Color.FromArgb(10, 0, 255, 255);
    Color color = btn.BackColor;
    MessageBox.Show($"点击的按钮的背景色：R={color.R},G={color.G},B={color.B},alpha={color.A}");
}
```

### 1.3.3. Brush
`System.Drawing.Brush`是所有brush类型的基类，它是一个抽象类，它的派生类包括：
+ HatchBrush：定义矩形画笔阴影样式、 前景颜色与背景色。
+ LinearGradientBrush：封装 System.Drawing.Brush 带有线性渐变。
+ PathGradientBrush：封装 System.Drawing.Brush 填充的内部对象 
+ SolidBrush： 画笔用于填充图形形状，如矩形、 椭圆、 饼、 多边形和路径。
+ TextureBrush：每个属性 System.Drawing.TextureBrush 类是 System.Drawing.Brush 用图像来填充形状的内部对象。

这几个派生类都是sealed class,不能被继承。


#### 1.3.3.1. 示例
以TextureBrush为例：
```csharp
 bool drawRectangle = false;
        private void btnTextureBrush_Click(object sender, EventArgs e)
        {
            drawRectangle = !drawRectangle;
            using (Graphics g = this.CreateGraphics())
            {
                if (this.drawRectangle)
                {
                    Image bitmap = new Bitmap(@"C:\Program Files (x86)\360\360zip\config\defaultskin\Skin.jpg");
                    TextureBrush textureBrush = new TextureBrush(bitmap);
                    textureBrush.WrapMode = WrapMode.TileFlipX;
                    g.FillRectangle(textureBrush, this.ClientRectangle);
                }
                else
                {
                    g.FillRectangle(SystemBrushes.Control, this.ClientRectangle);
                }
            }
        }
```



### 1.3.4. Pen
Brushes用来填充形状，而Pen用来画形状的框架。
`System.Drawing.Pen`是一个sealed class，没有派生类。

#### 1.3.4.1. 示例
```csharp
bool drawLine = false;
        private void btnDrawLine_Click(object sender, EventArgs e)
        {
            drawLine = !drawLine;
            using(Graphics g = this.CreateGraphics())
            {
                Pen pen = new Pen(Color.Blue,10.0F);
                //指定画笔开端的样式
                pen.StartCap = LineCap.RoundAnchor;
                //指定画笔末端的样式
                pen.EndCap = LineCap.ArrowAnchor;
                //Dash样式
                pen.DashStyle = DashStyle.Dot;
                //
                pen.Alignment = PenAlignment.Inset;
                //joins
                pen.LineJoin = LineJoin.Round;
                
                if (drawLine)
                {
                    g.DrawLine(pen, 300, 300, 600, 600);
                }
                else
                {
                    Pen pen1 = new Pen(SystemColors.Control, 10);
                    //指定画笔开端的样式
                    pen1.StartCap = LineCap.RoundAnchor;
                    pen1.EndCap = LineCap.ArrowAnchor;
                    g.DrawLine(pen1, 300, 300, 600, 600);
                }
            }
        }

```

### 1.3.5. Images
`System.Drawing.Image`：一个抽象基类，提供了用于功能 System.Drawing.Bitmap 和 System.Drawing.Imaging.Metafile 继承的类。

#### 1.3.5.1. 示例
```csharp
bool drawWMF = false;
        private void btnDrawWMF_Click(object sender, EventArgs e)
        {
            drawWMF = !drawWMF;
            using(Graphics g = this.CreateGraphics())
            {
                Rectangle rectangle = new Rectangle(500, 500, 200, 200);
                if (drawWMF)
                {
                    Metafile metafile = new Metafile(@"C:\Program Files\Microsoft Office\root\CLIPART\PUB60COR\AN00010_.WMF");
                    g.DrawImage(metafile, rectangle);
                }
                else
                {
                    Brush brush = new SolidBrush(SystemColors.Control);
                    g.FillRectangle(brush, rectangle);
                }
            }
        }
```


### Component
组件：Component是继承了`IComponent`接口的类，本质上，组件是可重用的、可配置的类。因此，他们没有通过表单提供对用户交互的本地支持，例如通过暴露一个UI由表单托管或处理键盘和鼠标输入。

对UI交互的内在支持是由**控件**完成，这一点区别也体现在控件和组件在窗口设计的位置上：控件在窗口上的可视设计面上，而组件是在非可视设计面，也叫组件托盘。
如下图所示：
[![vSUFtH.png](https://s1.ax1x.com/2022/07/27/vSUFtH.png)](https://imgtu.com/i/vSUFtH)


有一些控件（Controls）也在组件托盘上显示为伪组件，比如ToolStrip控件。


#### 使用组件
把组件拖放到窗口中，就可以像使用任何常规类一样使用组件。**创建新组件时，它将与表单上的其他组件一起放在容器管理的列表中。这允许表单跟踪托管组件，并提供自动资源管理。
**

比如，在把一个组件Timer添加到窗口上时，设计器会生成如下代码：
```csharp
private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.timer1 = new System.Windows.Forms.Timer(this.components);
            ...
	    }
```

使用Timer组件的示例：
```csharp
//设计器生成的代码
// timer1
// 
this.timer1.Enabled = true;
this.timer1.Interval = 1000;
this.timer1.Tick += new System.EventHandler(this.timer1_Tick);


//自己实现的事件处理方法
private void timer1_Tick(object sender, EventArgs e)
{
    Console.WriteLine(DateTime.Now);
}

```
上面两段代码分别在Designer.cs和.cs中，当窗口启动，每隔1s控制台输出当前日期时间。


