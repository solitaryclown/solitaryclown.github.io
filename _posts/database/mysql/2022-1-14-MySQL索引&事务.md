---
layout: post
date: 2022-01-14 16:05:30 +0800
author: solitaryclown
title: MySQL索引/事务
categories: database
tags: mysql
# permalink: /:categories/:title.html
excerpt: "MySQL索引的介绍和使用；MySQL事务介绍"
---
* content
{:toc}


# 1. MySQL索引
## 1.1. 作用
索引用于快速定位数据，而不必在每次访问数据库表时搜索数据库表中的每一行。可以使用数据库表的一个或多个列创建索引，为快速随机查找和有序记录的高效访问提供基础。

## 1.2. 分类
+ 单列索引
  1. 普通索引
  2. 唯一索引
  3. 主键索引
+ 组合索引
+ 全文索引
+ 空间索引

## 1.3. 使用
### 1.3.1. 创建
+ 建表时创建
  ```sql
  CREATE TABLE table_name (
	...
	index_type index_name名(column_list) 
  );
  ```
+ 建表后创建

    ```sql
    -- 方法1
    create index index_name on table_name(column_list); 

    -- 方法2
    alter table table_name add index_name 索引名(column_list);
    ```

### 1.3.2. 查看

查看数据库所有索引状态：

```sql
SELECT *FROM mysql.innodb_index_stats I WHERE I.database_name='database_name';
```
查看某个表的索引：`SHOW INDEX FROM table_name;`

### 1.3.3. 删除
删除某表的某个索引：  
`DROP INDEX NAME ON student;`或` ALTER TABLE table_name DROP INDEX index_name;`




## 1.4. 原理
一般来讲，索引本身数据量也很大，不可能全部放在内存中，因此索引常常以索引文件的形式存放在硬盘中，但文件I/O是很消耗资源的工作，因此，评价一个数据结构作为索引结构的好坏的一个重要指标就是**磁盘I/O次数**。


### 1.4.1. 索引数据结构
#### 1.4.1.1. hash表
+ 优点：定位数据速度很快
+ 缺点：散列表中的值无序，不能进行范围查找，比如对于“where a>?”这种条件的查找。

#### 1.4.1.2. B树和B+树
B树和B+树的主要区别：
+ B+树的叶子结点存储key和value，非叶子结点只存储key，B树的所有节点都存储key和value
+ B+树的叶子结点通过指针相连，B树没有。

degree为3的，B树和B+树的结构如下所示：  
*B树*：  
[![7JpKvn.png](https://s4.ax1x.com/2022/01/15/7JpKvn.png)](https://imgtu.com/i/7JpKvn)

*B+树*：  
[![7JpQuq.png](https://s4.ax1x.com/2022/01/15/7JpQuq.png)](https://imgtu.com/i/7JpQuq)



# 2. MySQL事务

## 2.1. 定义
数据库事务是 DBMS 中的一个逻辑处理单元，它需要一个或多个数据库访问操作。在 DBMS 中，开始和结束事务语句之间的所有类型的数据库访问操作都被认为是一个单一的逻辑事务。在事务处理期间，数据库不一致。只有在提交数据库之后，状态才会从一个一致状态更改为另一个一致状态。

## 2.2. 操作
+ 开启事务：`BEGIN`或`START TRANSACTION`
+ 提交事务：`COMMIT`
+ 回滚：`ROLLBACK`

关闭/开启事务自动提交：`SET autocommit=0`/`SET autocommit=1`

## 2.3. 特性——ACID
ACID：
1. 原子性（Atomic）：事务不可分割，事务中的任务要么全部成功，要么全部失败。
2. 一致性（consistently）：事务将数据库从一个一致状态迁移到另一个一致状态。
3. 隔离性（isolation）：不同的事务之间相互隔离，互不干扰。
4. 持久性（durability）：事务提交后，数据库状态的修改是永久性的。


## 2.4. 事务隔离级别
事物的隔离级别由低到高一共有4种：READ UNCOMMITED、READ COMMITED、REPEATABLE RAED、Serializable；

设置事务的隔离级别：`SET SESSION TRANSACTION ISOLATION LEVEL 隔离级别;`



### 2.4.1. read uncommitted
事务可以读取其他事务没有提交的数据。

### 2.4.2. read committed
一个事务必须等其他事务提交才能读取数据

### 2.4.3. repeatable read（InnoDB默认隔离级别）
事务在读取时不允许其他事务进行写入操作，可重复读，即同一个事务内两次读取同一条记录是一致的。

### 2.4.4. Serializable
处于这个隔离级别的事务都是串行化执行，同一时刻只能有一个事务正在执行。


### 2.4.5. 并发事务可能引发的问题
#### 2.4.5.1. 脏读
脏读：事务T1读取到事务T2没有提交的数据
  [![7YMOiQ.png](https://s4.ax1x.com/2022/01/15/7YMOiQ.png)](https://imgtu.com/i/7YMOiQ)
#### 2.4.5.2. 不可重复读
不可重复读：事务T1在执行期间多次读取同一行的数据，在多次读取的间隔之间，事务T2对数据进行了修改，导致T1多次读取同一行的数据结果不一致。
  [![7t3o24.md.png](https://s4.ax1x.com/2022/01/16/7t3o24.md.png)](https://imgtu.com/i/7t3o24)
#### 2.4.5.3. 幻读
幻读：同一事务内，由选择操作获得的结果集表示的数据状态不能支持后续的业务操作。例如：选择记录不存在，可以插入。但是，当插入时，发现记录已经存在并且无法插入。
[![7t8HfS.png](https://s4.ax1x.com/2022/01/16/7t8HfS.png)](https://imgtu.com/i/7t8HfS)

**对幻读的错误理解：同一事务内同一条选择语句获得的结果不一致（即使在两次选择操作之间其他事务执行了提交操作），事实上，这属于不可重复读。这种情况只会出现在R-U(read uncommitted)和R-C级别，不会出现在InnoDB默认的RR级别**