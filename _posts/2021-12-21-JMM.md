---
layout: post
date: 2021-12-21 15:00:04 +0800
author: solitaryclown
categories: 
tags: 
# permalink: /:categories/:title.html
excerpt: "JMM,Java Memory Model，Java内存模型，JMM的建立围绕三个特征：原子性、可见性、有序性。"
---
* content
{:toc}

# JMM
* 原子性：保证指令的执行不受线程上下文切换的影响
* 可见性：保证指令的执行不会收到CPU cache的影响
* 有序性：保证指令执行顺序不会受到cpu指令并行优化的影响

## 保证可见性
### 例子
```java
package com.huangbei.test1;


import com.huangbei.util.Sleeper;
import lombok.extern.slf4j.Slf4j;

@Slf4j(topic = "c.Test5")
public class Test5 {
    volatile  static boolean flag=true;
    public static void main(String[] args) {
        new Thread(()->{
            while (flag){
                ;
            }
        },"t1").start();
        Sleeper.sleep(1);
        log.debug("修改flag=false");
        flag=false;

    }
}

```
在上面的测试中，主线程对flag进行了修改，但是t1线程读到的flag一直都是true，因为t1每次读的flag值都是自己的工作内存中对初始化的flag的一份拷贝，导致t1线程无法结束运行。
### 解决
- 对共享变量（成员变量）使用`volatile`关键字，保证线程每次读到的变量值都是最新值。
- 对共享变量加锁`synchronized`（线程获取锁后，线程工作内存中对共享变量的拷贝全部失效，线程必须从主内存读取共享变量的值；释放锁时，会将工作内存中的值同步到主内存中。）


